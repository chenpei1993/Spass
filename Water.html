<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Water</title>
</head>
<body>
<canvas id = "my-canvas"></canvas>
<script type="module">
    import Camera from "./js/Camera/Camera.js";
    import OrbitCameraController from "./js/Camera/OrbitCameraController.js";
    import Shader from "./js/Material/Shader.js";
    import Mesh from "./js/Mesh/Mesh.js";
    import Spass from "./js/Core/Spass.js";
    import {Cube} from "./js/Geometry/Cube.js";
    import GridShader from "./js/Material/GridShader.js";
    import {GridFloor} from "./js/Geometry/GridFloor.js";
    import {Grid} from "./js/Geometry/Grid.js";

    const canvasEle = document.getElementById("my-canvas")
    canvasEle.width = window.innerWidth
    canvasEle.height = window.innerHeight
    const gl = canvasEle.getContext("webgl2")
    const app = new Spass(gl)

    let camera = new Camera(canvasEle.width / canvasEle.height)
    camera.position(0, 5, 15)
    app.setCamera(camera)

    let controller = new OrbitCameraController(camera, canvasEle)

    let vertexShaderSrc = `#version 300 es
      in vec4 a_position;
      in vec3 a_norm;

      uniform mat4 uModelViewMatrix;
      uniform mat4 uCameraViewMatrix;
      uniform mat4 uProjectViewMatrix;
      uniform float uTime;

      out vec3 v_norm;
      out vec3 v_position;

      vec3 permute(vec3 x) {
        return mod(((x * 34.0) + 1.0) * x, 289.0);
      }

      float snoise(vec2 v) {
          const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
          vec2 i = floor(v + dot(v, C.yy));
          vec2 x0 = v - i + dot(i, C.xx);
          vec2 i1;
          i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
          vec4 x12 = x0.xyxy + C.xxzz;
          x12.xy -= i1;
          i = mod(i, 289.0);
          vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
          vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
          m = m * m;
          m = m * m;
          vec3 x = 2.0 * fract(p * C.www) - 1.0;
          vec3 h = abs(x) - 0.5;
          vec3 ox = floor(x + 0.5);
          vec3 a0 = x - ox;
          m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);
          vec3 g;
          g.x = a0.x * x0.x + h.x * x0.y;
          g.yz = a0.yz * x12.xz + h.yz * x12.yw;
          return 130.0 * dot(m, g);
      }

      float getElevation(float x, float z) {
            vec2 pos = vec2(x, z);

            float elevation = 0.0;
            float amplitude = 1.0;
            // float frequency = uWavesFrequency;
            //
            float uWavesPersistence = 0.3;
            float uWavesLacunarity = 2.18;
            float uWavesAmplitude = 0.25;
            float uWavesIterations = 8.0;
            float uWavesSpeed = 0.4;

            float frequency = 1.07;
            vec2 p = pos.xy;

            for(float i = 0.0; i < uWavesIterations; i++) {
                float noiseValue = snoise(p * frequency + uTime * uWavesSpeed);
                elevation += amplitude * noiseValue;
                amplitude *= uWavesPersistence;
                frequency *= uWavesLacunarity;
            }

            elevation *= uWavesAmplitude;

            return elevation;
        }

      void main(void){
        vec4 modelPosition = uModelViewMatrix * vec4(a_position.xyz, 1.0);

        float elevation = getElevation(modelPosition.x, modelPosition.z);
        modelPosition.y += elevation;

        float eps = 0.001;
        //TODO 重新计算法线
        // vec3 tangent = normalize(vec3(eps, getElevation(modelPosition.x - eps, modelPosition.z) - elevation, 0.0));
        // vec3 bitangent = normalize(vec3(0.0, getElevation(modelPosition.x, modelPosition.z - eps) - elevation, eps));
        // vec3 objectNormal = normalize(cross(tangent, bitangent));

        gl_Position =   uProjectViewMatrix  * uCameraViewMatrix * modelPosition;
        v_norm = a_norm;
        v_position = a_position.xyz;
      }
    `
    let fragmentShaderSrc =  `#version 300 es
      precision mediump float;
      in vec3 v_position;
      in vec3 v_norm;

      uniform vec3 uLightPos;
      uniform vec3 uCameraPos;


      out vec4 outColor;
      void main(void){

        vec3 cLight = vec3(1.0, 1.0, 1.0);


        //环境光
        float ambientStrength = 0.15;
        vec3 cAmbient = ambientStrength * cLight;

        //漫反射
        vec3 lightDir = normalize(uLightPos - v_position);

        float diffAngle = max(dot(v_norm, lightDir),0.0);

        float diffuseStrength = 1.0;
        vec3 cDiffuse = diffAngle * cLight * diffuseStrength;

        //镜面光
        // 归一化向量
        float shininess = 0.5;
        vec3 k_spec = vec3(0.1, 0.1, 0.1);
        vec3 N = normalize(v_norm);
        vec3 L = normalize(uLightPos - v_position);
        vec3 V = normalize(uCameraPos - v_position);

        // 计算反射向量
        vec3 R = reflect(-L, N);

        // 计算镜面光
        float spec = pow(max(dot(R, V), 0.0), shininess);
        vec3 cSpecular = k_spec * spec;

        float h = v_position.y;

        vec4 cBase = vec4(0.0, 0.75, 1.0, 0.5);
        vec4 cBlue = vec4(0.0, 0.0, 1.0, 0.5);
        vec4 color = mix(cBase, cBlue, 0.3 + h);

        // vec3 finalColor = (cAmbient + cDiffuse + cSpecular) * cBase.rgb;
        vec3 finalColor = (cAmbient + cDiffuse + cSpecular) * color.rgb;
        outColor = vec4(finalColor, 1.0);
      }
    `


    const gridShader = new GridShader()
    let gridFloor = new GridFloor()
    let gridMesh = new Mesh(gridFloor, gridShader)
    app.scene.add(gridMesh)


    const shader = new Shader(vertexShaderSrc, fragmentShaderSrc)
    let cube = new Grid(32, 32, -16,-16, 1, 1)
    let waterMesh = new Mesh(cube, shader)
    waterMesh.setPosition(0, 1, 0)
    waterMesh.setUniform("uTime", "float", 1)
    waterMesh.setUniform("uLightPos", "vec3", [0.0, 10.0, 0.0])
    waterMesh.setUniform("uCameraPos", "vec3", camera.getPosition().getArray())
    app.scene.add(waterMesh)


    let start = Date.now()
    function onRender(){
        // mesh.rotateX(Math.PI * 0.02)
        app.render()
        let t = (Date.now() - start) / 1000;
        setTimeout(() => {
            waterMesh.setUniform("uTime", "float", t)
            waterMesh.setUniform("uCameraPos", "vec3", camera.getPosition().getArray())
        }, 1000)
        window.requestAnimationFrame(onRender)
    }

    window.requestAnimationFrame(onRender)


</script>
</body>
</html>